name: Check Update and Create Release

on:
  schedule:
    # Run daily at 00:00 UTC
    - cron: '0 0 * * *'
  workflow_dispatch: # Allow manual trigger

permissions:
  contents: write

jobs:
  update-data:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Fetch stable versions
        id: fetch
        run: |
          # Create a Node.js script to fetch stable versions
          cat > fetch-stable.js << 'EOF'
          const https = require('https');
          const fs = require('fs');

          const apps = [
            {
              guid: "{8A69D345-D564-463C-AFF1-A69D9E530F96}",
              flavors: [
                {
                  tag: "Google_Chrome",
                  name: "Google Chrome",
                  arch: "x86",
                  extra: { ap: "x86-stable-statsdef_1" }
                },
                {
                  tag: "Google_Chrome_64",
                  name: "Google Chrome x64",
                  arch: "x64",
                  extra: { ap: "x64-stable-statsdef_1" }
                }
              ]
            },
            {
              guid: "{47B07D71-505D-4665-AFD4-4972A30C6530}",
              flavors: [
                {
                  tag: "Google_Play_Games_Beta",
                  name: "Google Play Games Beta",
                  arch: "x64",
                  extra: { ap: "beta" }
                }
              ]
            },
            {
              guid: "{C601E9A4-03B0-4188-843E-80058BF16EF9}",
              flavors: [
                {
                  tag: "GPG_Developer_Emulator_Stable",
                  name: "Google Play Games Developer Emulator",
                  arch: "x64",
                  extra: { ap: "prod" }
                }
              ]
            },
            {
              guid: "{232066FE-FF4D-4C25-83B4-3F8747CF7E3A}",
              flavors: [
                {
                  tag: "Nearby_Better_Together",
                  name: "Quick Share",
                  arch: "x64"
                }
              ]
            },
            {
              guid: "{65E60E95-0DE9-43FF-9F3F-4F7D2DFF04B5}",
              flavors: [
                {
                  tag: "Google_Earth_Pro",
                  name: "Google Earth Pro",
                  arch: "x86"
                },
                {
                  tag: "Google_Earth_Pro_64",
                  name: "Google Earth Pro x64",
                  arch: "x64"
                }
              ]
            }
          ];

          function makeRequest(body) {
            return new Promise((resolve, reject) => {
              const postData = JSON.stringify(body);

              const options = {
                hostname: 'update.googleapis.com',
                path: '/service/update2/json',
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Content-Length': Buffer.byteLength(postData)
                }
              };

              const req = https.request(options, (res) => {
                let data = '';
                res.on('data', (chunk) => { data += chunk; });
                res.on('end', () => {
                  if (res.statusCode === 200) {
                    // Remove safe JSON prefix )]}'\n
                    const jsonData = data.substring(5);
                    resolve(JSON.parse(jsonData));
                  } else {
                    reject(new Error(`HTTP ${res.statusCode}`));
                  }
                });
              });

              req.on('error', reject);
              req.write(postData);
              req.end();
            });
          }

          async function fetchStableVersions() {
            const results = [];

            for (const app of apps) {
              for (const flavor of app.flavors) {

                // // Only fetch for stable versions (skip Beta, Dev, Canary)
                // if (!flavor.tag.includes('Stable') && !flavor.tag.match(/Share|PlayGames/i)) {
                //   continue;
                // }

                const body = {
                  request: {
                    "@os": "win",
                    "@updater": "updater",
                    "acceptformat": "exe",
                    "app": [{
                      appid: app.guid,
                      updatecheck: {},
                      version: "0.0.0.0",
                      ...flavor.extra
                    }],
                    "arch": flavor.arch,
                    "dedup": "cr",
                    "domainjoined": false,
                    "hw": {
                        avx: true,
                        physmemory: 16,
                        sse: true,
                        sse2: true,
                        sse3: true,
                        sse41: true,
                        sse42: true,
                        ssse3: true,
                    },
                    "ismachine": true,
                    "os": {
                      arch: flavor.arch,
                      platform: "win",
                      version: "10.0.19045.6456", // Windows 10 22H2 (Build 19045.6456) KB5066791
                    },
                    "protocol": "3.1"
                  }
                };

                try {
                  const response = await makeRequest(body);
                  const appResponse = response.response.app[0];

                  if (appResponse.updatecheck.status === "ok") {
                    const updatecheck = appResponse.updatecheck;
                    const version = updatecheck.manifest.version;
                    const url = updatecheck.urls.url.find(u =>
                      u.codebase.startsWith("https://dl.google.com")
                    ) || updatecheck.urls.url[0];
                    const pkg = updatecheck.manifest.packages.package[0];

                    results.push({
                      name: flavor.name,
                      tag: flavor.tag,
                      appid: app.guid,
                      version: version,
                      cohortname: appResponse.cohortname || "N/A",
                      arguments: updatecheck.manifest.arguments || "",
                      download: url.codebase + pkg.name,
                      size: parseInt(pkg.size),
                      sha256: pkg.hash_sha256
                    });
                  }
                } catch (error) {
                  console.error(`Error fetching ${flavor.name}:`, error.message);
                }
              }
            }

            return results;
          }

          function compareVersions(v1, v2) {
            const parts1 = v1.split('.').map(Number);
            const parts2 = v2.split('.').map(Number);

            for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
              const p1 = parts1[i] || 0;
              const p2 = parts2[i] || 0;
              if (p1 > p2) return -1; // v1 is newer
              if (p1 < p2) return 1;  // v2 is newer
            }
            return 0; // equal
          }

          fetchStableVersions().then(results => {
            // Load existing data.json if it exists
            let existingData = [];
            if (fs.existsSync('data.json')) {
              try {
                existingData = JSON.parse(fs.readFileSync('data.json', 'utf8'));
              } catch (error) {
                console.log('Could not parse existing data.json, starting fresh');
              }
            }

            // Convert existing data to new format if needed
            const productMap = new Map();

            // Process existing data
            existingData.forEach(item => {
              const key = `${item.tag}_${item.appid}`;
              if (!productMap.has(key)) {
                productMap.set(key, {
                  name: item.name,
                  tag: item.tag,
                  appid: item.appid,
                  versions: {}
                });
              }
              const product = productMap.get(key);

              // Handle both old and new format
              if (item.versions) {
                // New format: merge all versions
                Object.assign(product.versions, item.versions);
              } else if (item.version) {
                // Old format: add single version
                product.versions[item.version] = {
                  download: item.download,
                  size: item.size,
                  sha256: item.sha256
                };
              }
            });

            // Add new results
            results.forEach(item => {
              const key = `${item.tag}_${item.appid}`;
              if (!productMap.has(key)) {
                productMap.set(key, {
                  name: item.name,
                  tag: item.tag,
                  appid: item.appid,
                  versions: {}
                });
              }
              const product = productMap.get(key);
              product.versions[item.version] = {
                download: item.download,
                size: item.size,
                sha256: item.sha256
              };
            });

            // Convert map to array and sort versions (newest first)
            const output = Array.from(productMap.values()).map(product => {
              // Sort versions in descending order (newest first)
              const sortedVersions = {};
              Object.keys(product.versions)
                .sort(compareVersions)
                .forEach(version => {
                  sortedVersions[version] = product.versions[version];
                });

              return {
                name: product.name,
                tag: product.tag,
                appid: product.appid,
                versions: sortedVersions
              };
            });

            fs.writeFileSync('data.json', JSON.stringify(output, null, 2));
            console.log('Data saved to data.json');

            // Output for GitHub Actions
            const ghOutput = process.env.GITHUB_OUTPUT;
            if (ghOutput) {
              if (results.length > 0) {
                fs.appendFileSync(ghOutput, `has_updates=true\n`);
                fs.appendFileSync(ghOutput, `version=${results[0].version}\n`);
              } else {
                fs.appendFileSync(ghOutput, `has_updates=false\n`);
              }
            }
          }).catch(error => {
            console.error('Fatal error:', error);
            process.exit(1);
          });
          EOF

          node fetch-stable.js

      - name: Check for changes
        id: check_changes
        run: |
          # Check if data.json has changes (modified) or is new (untracked)
          if [ -f data.json ] && ! git ls-files --error-unmatch data.json > /dev/null 2>&1; then
            # File exists but is not tracked - it's new
            echo "changed=true" >> $GITHUB_OUTPUT
          elif git ls-files --error-unmatch data.json > /dev/null 2>&1; then
            # File is tracked, check if it has changes
            if ! git diff --exit-code data.json > /dev/null 2>&1; then
              echo "changed=true" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Commit and push data.json
        if: steps.check_changes.outputs.changed == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add data.json
          git commit -m "ðŸ¤– Automatic data update at $(date +'%Y-%m-%d')"
          git push

      # Disabled: Auto create release
      # - name: Create release with installers
      #   if: steps.check_changes.outputs.changed == 'true'
      #   env:
      #     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      #   run: |
      #     # Get current date for tag
      #     TAG_NAME=$(date +'%Y%m%d')
      #
      #     # Check if tag already exists
      #     if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
      #       echo "Tag $TAG_NAME already exists, skipping release"
      #       exit 0
      #     fi
      #
      #     # Create release notes from data.json
      #     cat > release_notes.md << 'EOF'
      #     # Stable Version Updates
      #
      #     This release contains the latest stable versions of Google products.
      #
      #     ## Versions
      #     EOF
      #
      #     node -e "
      #     const data = require('./data.json');
      #     data.forEach(item => {
      #       console.log(\`- **\${item.name}**: v\${item.version}\`);
      #     });
      #     " >> release_notes.md
      #
      #     # Create GitHub release
      #     gh release create "$TAG_NAME" \
      #       --title "Stable Versions - $(date +'%Y-%m-%d')" \
      #       --notes-file release_notes.md
      #
      #     # Download and attach installers for Chrome Stable only
      #     node -e "
      #     const https = require('https');
      #     const fs = require('fs');
      #     const data = require('./data.json');
      #
      #     const chromeStable = data.find(item => item.tag === 'ChromeStable');
      #     if (!chromeStable) {
      #       console.log('Chrome Stable not found');
      #       process.exit(0);
      #     }
      #
      #     const url = chromeStable.download;
      #     const filename = url.split('/').pop();
      #
      #     console.log('Downloading:', filename);
      #
      #     https.get(url, (response) => {
      #       if (response.statusCode === 302 || response.statusCode === 301) {
      #         // Follow redirect
      #         https.get(response.headers.location, (res) => {
      #           const file = fs.createWriteStream(filename);
      #           res.pipe(file);
      #           file.on('finish', () => {
      #             file.close();
      #             console.log('Downloaded:', filename);
      #           });
      #         });
      #       } else {
      #         const file = fs.createWriteStream(filename);
      #         response.pipe(file);
      #         file.on('finish', () => {
      #           file.close();
      #           console.log('Downloaded:', filename);
      #         });
      #       }
      #     }).on('error', (err) => {
      #       console.error('Download failed:', err.message);
      #     });
      #     " || echo "Download skipped or failed"
      #
      #     # Wait a bit for download to complete (if any)
      #     sleep 10
      #
      #     # Upload installers if they exist
      #     for file in *.exe; do
      #       if [ -f "$file" ]; then
      #         echo "Uploading $file to release..."
      #         gh release upload "$TAG_NAME" "$file" || echo "Upload failed for $file"
      #       fi
      #     done
